# Estimation of the state of an object.
#
# An object can be in one of a given number of states, but the state must be
# inferred from noisy data. 
#
# The state of the object evolves over time, but once it has crossed to the next
# state in the sequence, it cannot return.
#
# Observations are provided about the object, but those observations are not
# under any control, so they arrive when they are generated by an external
# source. The external system may not send data it collects to the inference 
# engine, but the probability of missing observations can be assumed to follow
# a parametric distribution.
#
# Observations from the external system do not uniquely define the state that
# the object is in, i.e. there is some ambiguity.
#
# The problem is to estimate the state of the object from the noisy and missing
# observations.

import itertools
import math
import matplotlib.pyplot as plt
import numpy as np
import random


def stage_changepoints(num_stages, tau_max):
    """Returns a list of stage changepoints."""

    assert num_stages > 1
    assert num_stages < tau_max, f"Too many stages ({num_stages}) for time {tau_max}"

    num_changepoints = num_stages - 1

    # Sample without replacement
    changepoints = random.sample(range(tau_max), num_changepoints)

    # Return a sorted list of changepoints in time order
    changepoints = sorted(changepoints)

    assert len(changepoints) == num_changepoints
    assert len(set(changepoints)) == len(changepoints), f"Changepoints {changepoints} aren't unique"
    assert max(changepoints) < tau_max

    return changepoints


def gen_events_for_stage(t_min, t_max, p_event):
    """Generate events for the stage with time t_min <= t < t_max."""

    assert t_min >= 0
    assert t_min <= t_max, f"Invalid times {t_min}, {t_max}"
    assert abs(sum(p_event) - 1.0) < 1e-6, f"Probability doesn't sum to 1"

    if t_min == t_max:
        return np.array([]), np.array([], dtype=int)

    # Number of events in the stage to generate
    prop = np.random.uniform(0, 0.8)
    tau = t_max - t_min
    num_events = max(math.floor(prop*tau), 1)

    # Times of the events 
    event_times = sorted(random.sample(range(t_min, t_max), num_events))
    assert len(event_times) == num_events
    assert len(set(event_times)) == num_events, f"Event times aren't unique: {event_times}"

    # Types of events
    event_types = [int(np.where(np.random.multinomial(1, p_event) == 1)[0][0]) for _ in range(num_events)]
    assert len(event_types) == num_events, f"Got {len(event_types)}, expected {num_events}"

    # Return a tuple of event times and event types
    assert len(event_times) == len(event_types)
    return event_times, event_types
    

def generate_obs(p_s, cpt, tau_max):
    """Generate synthetic observations."""

    assert abs(sum(p_s) - 1.0 < 1e-6), f"Probability doesn't sum to 1"
    assert tau_max > 0

    # Sample to get the number of stages
    num_stages = np.where(np.random.multinomial(1, p_s) == 1)[0][0] + 1
    print(f"Number of stages: {num_stages}")

    if num_stages == 1:
        event_times, event_types = gen_events_for_stage(0, tau_max, cpt[0])
        gt_stages = np.repeat(0, len(event_times))
        changepoints = []
    else:
        # Determine the stage changepoints
        changepoints = stage_changepoints(num_stages, tau_max)
        print(f"Changepoints: {changepoints}")

        # Generate the ground truth stage, event time, event type
        gt_stages = np.array([])
        event_times = np.array([])
        event_types = np.array([], dtype=int)

        # Walk through each stage
        for s in range(num_stages):
            if s == 0:
                t_min = 0
                t_max = changepoints[0]
            elif s == num_stages - 1:
                t_min = changepoints[-1]
                t_max = tau_max
            else:
                t_min = changepoints[s-1]
                t_max = changepoints[s]

            assert s < cpt.shape[0], f"Insufficient rows in CPT for stage {s}"
            event_times_s, event_types_s = gen_events_for_stage(t_min, t_max, cpt[s])

            num_events = len(event_times_s)
            print(f"Generated {num_events} events for stage {s} / {num_stages - 1}")

            gt_stages = np.append(gt_stages, np.repeat(s, num_events))
            event_times = np.append(event_times, event_times_s)
            event_types = np.append(event_types, event_types_s)

    assert len(gt_stages) == len(event_times), f"gt_stages = {gt_stages}, event_times = {event_times}"
    assert len(gt_stages) == len(event_types), f"gt_stages = {gt_stages}, event_types = {event_types}"

    return gt_stages, event_times, event_types, changepoints


def indicator(event_time, stage, changepoints, tau_max):
    """Indicator function returns 1 if event time is between changepoints, otherwise 0."""

    if len(changepoints) == 0:
        return 1.0

    if stage == 0:
        t_min = 0
        t_max = changepoints[0]
    elif stage == len(changepoints):
        t_min = changepoints[-1]
        t_max = tau_max
    else:
        t_min = changepoints[stage - 1]
        t_max = changepoints[stage]

    if t_min <= event_time < t_max:
        return 1.0
    else:
        return 0.0
    

def test_indicator():
    """Unit tests for indicator()."""

    # One stage (no changepoints)
    assert indicator(0, 0, [], 20) == 1.0
    assert indicator(19, 0, [], 20) == 1.0

    # Two stages (1 changepoint)
    assert indicator(0, 0, [10], 20) == 1.0
    assert indicator(9, 0, [10], 20) == 1.0
    assert indicator(10, 0, [10], 20) == 0.0
    assert indicator(0, 1, [10], 20) == 0.0
    assert indicator(9, 1, [10], 20) == 0.0
    assert indicator(10, 1, [10], 20) == 1.0
    assert indicator(19, 1, [10], 20) == 1.0

    # Three stages (2 changepoints)
    assert indicator(0, 0, [10, 15], 20) == 1.0
    assert indicator(0, 1, [10, 15], 20) == 0.0
    assert indicator(0, 2, [10, 15], 20) == 0.0
    assert indicator(10, 0, [10, 15], 20) == 0.0
    assert indicator(10, 1, [10, 15], 20) == 1.0
    assert indicator(10, 2, [10, 15], 20) == 0.0
    assert indicator(15, 0, [10, 15], 20) == 0.0
    assert indicator(15, 1, [10, 15], 20) == 0.0
    assert indicator(15, 2, [10, 15], 20) == 1.0
    assert indicator(19, 2, [10, 15], 20) == 1.0


def log_likelihood(event_times, event_types, changepoints, cpt, tau_max):
    """Calculate the log-likelihood."""

    assert len(event_times) == len(event_types)

    total = 0.0
    for s in range(len(changepoints) + 1):
        for k in range(len(event_times)):
            assert s < cpt.shape[0], f"Stage {s} out of range for CPT"
            assert event_types[k] < cpt.shape[1], f"Event type {event_types[k]} out of range for CPT"

            # Add on a small number in case the probability from the CPT is 0
            p = cpt[s, event_types[k]] + 1e-16
            total += indicator(event_times[k], s, changepoints, tau_max) * math.log(p)

    return total


def test_log_likelihood():
    """Unit tests for log_likelihood()."""

    cpt = np.array([
        [0.2, 0.5, 0.3],
        [0.7, 0.1, 0.2],
        [0.3, 0.2, 0.5]
    ])

    # event_times, event_types, changepoints, tau_max, expected log likelihood
    test_cases = [
        [ [0], [0], [5, 9], 10, math.log(0.2) ], # stage 0
        [ [6], [0], [5, 9], 10, math.log(0.7) ], # stage 1
        [ [9], [0], [5, 9], 10, math.log(0.3) ], # stage 2
        [ [0, 4], [0, 0], [5, 9], 10, math.log(0.2) + math.log(0.2) ], # 2 x stage 0
        [ [0, 4], [0, 1], [5, 9], 10, math.log(0.2) + math.log(0.5) ], # 2 x stage 0
        [ [5, 4], [0, 1], [5, 9], 10, math.log(0.7) + math.log(0.5) ], # stage 1, 0
        [ [4, 5, 9], [0, 1, 2], [5, 9], 10, math.log(0.2) + math.log(0.1) + math.log(0.5) ], # stage 0, 1, 2
    ]
    
    for t in test_cases:
        event_times, event_types, changepoints, tau_max, expected = t
        actual = log_likelihood(event_times, event_types, changepoints, cpt, tau_max)
        assert abs(actual - expected) < 1e-6, f"actual: {actual}, expected: {expected}"


def valid_changepoints(seq):
    """Does the sequence represent valid changepoints?"""

    if len(seq) == 1:
        return True
    
    for i in range(len(seq) - 1):
        if seq[i] >= seq[i+1]:
            return False
        
    return True


def test_valid_changepoints():
    """Test valid_changepoints()."""

    assert valid_changepoints([0])
    assert not valid_changepoints([0, 0])
    assert valid_changepoints([0, 1])
    assert valid_changepoints([0, 2])
    assert not valid_changepoints([1, 0])
    assert not valid_changepoints([1, 1])
    assert valid_changepoints([0, 1, 2])
    assert not valid_changepoints([0, 1, 1])
    assert not valid_changepoints([0, 2, 1])
    assert not valid_changepoints([2, 0, 1])


def all_changepoints(num_changepoints, tau_max):
    """Construct a list of all possible (valid) changepoint positions."""

    assert num_changepoints >= 0
    assert tau_max >= 0

    if num_changepoints == 0:
        return []
    
    if tau_max == 0:
        return []

    changepoints = []

    x = list(range(tau_max))
    y = [x for _ in range(num_changepoints)]
    for seq in itertools.product(*y):
        if valid_changepoints(seq):
            changepoints.append(seq)

    return changepoints


def test_all_changepoints():
    """Unit tests for all_changepoints()."""

    assert all_changepoints(0, 3) == []
    assert all_changepoints(1, 3) == [(0, ), (1, ), (2, )]    
    assert all_changepoints(2, 3) == [(0, 1), (0, 2), (1, 2)]
    assert all_changepoints(2, 4) == [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
    assert all_changepoints(3, 4) == [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]


def run_inference(event_times, event_types, p_s, cpt, tau_max):
    """Run inference."""

    assert len(event_times) == len(event_types)

    joint_probs = []

    # Maximum number of changepoints
    num_changepoints = len(p_s) - 1

    # Walk through each possible configuration of changepoints
    for changepoints in all_changepoints(num_changepoints, tau_max):

        # Walk through the number of stages in the model
        for s in range(num_changepoints + 1):
            select_changepoints = changepoints[:s]

            ll = log_likelihood(event_times, event_types, select_changepoints, cpt, tau_max)
            prior_s = p_s[s]
            prior_tau = 1.0
            joint = math.exp(ll) * prior_s * prior_tau
            joint_probs.append((s+1, changepoints, joint))

    return joint_probs


def p_num_stages(joint_probs, L):
    """Probability of the number of stages from the joint."""

    total_for_num_stages = np.repeat(0.0, L)
    total = 0.0

    for j in joint_probs:
        num_stages, _, joint = j
        total_for_num_stages[num_stages - 1] += joint
        total += joint
    
    return total_for_num_stages / total


def trim_events(event_times, event_types, t):
    """Retain events up to a given time."""

    assert len(event_times) == len(event_types)
    assert t >= 0

    event_times_in_range = np.array([])
    event_types_in_range = np.array([], dtype=int)

    for i in range(len(event_times)):
        if event_times[i] < t:
            event_times_in_range = np.append(event_times_in_range, event_times[i])
            event_types_in_range = np.append(event_types_in_range, event_types[i])

    return event_times_in_range, event_types_in_range


def test_trim_events():
    # event_times, event_types, t (cut-off), exp_times, exp_types 
    test_cases = [
        [np.array([0, 3]), np.array([1, 2]), 0, np.array([]), np.array([])],
        [np.array([0, 3]), np.array([1, 2]), 1, np.array([0]), np.array([1])],
        [np.array([0, 3]), np.array([1, 2]), 4, np.array([0, 3]), np.array([1, 2])]
    ]

    for t in test_cases:
        actual_times, actual_types = trim_events(t[0], t[1], t[2])
        assert np.allclose(actual_times, t[3])
        assert np.allclose(actual_types, t[4])


def prob_num_stages_over_time(event_times, event_types, p_s, cpt, tau_max):
    """Calculate the probability of the number of stages over time."""

    # Matrix to hold the probability of the number of stages
    m = np.zeros((len(p_s), tau_max))

    for t in range(tau_max):

        # Only retain the events up to time t
        event_times_in_range, event_types_in_range = trim_events(event_times, event_types, t)

        joint_probs = run_inference(event_times_in_range, event_types_in_range, p_s, cpt, t)
        m[:,t] = p_num_stages(joint_probs, len(p_s))

    return m


if __name__ == '__main__':

    # Run unit tests
    test_indicator()
    test_log_likelihood()
    test_valid_changepoints()
    test_all_changepoints()
    test_trim_events()

    # Number of time steps
    tau_max = 40

    # Distribution of the number of stages
    #               1    2    3
    p_s = np.array([0.6, 0.3, 0.1])

    # Distribution of the number of stages when generating synthetic data
    #                   1    2    3
    p_s_gen = np.array([0.2, 0.6, 0.2])

    # CPT defining the probability of a given event type given the stage
    cpt = np.array([ 
        [0.1, 0.1, 0.7, 0.1, 0.0], 
        [0.1, 0.7, 0.1, 0.1, 0.0], 
        [0.0, 0.1, 0.1, 0.7, 0.1]])

    # CPT with perfect information about a given stage.
    # cpt = np.array([
    #     [1, 0, 0, 0, 0],
    #     [0, 1, 0, 0, 0],
    #     [0, 0, 1, 0, 0]
    # ])

    # Generate the ground truth stage and observed events
    gt_stages, event_times, event_types, gt_changepoints = generate_obs(p_s_gen, cpt, tau_max)
    print(f"Ground truth stages: {gt_stages}")
    print(f"Event times: {event_times}")
    print(f"Event types: {event_types}")
    print(f"Changepoints: {gt_changepoints}")

    # Run the inference
    joint_probs = run_inference(event_times, event_types, p_s, cpt, tau_max)
    print(f"Number of joint probabilities: {len(joint_probs)}")

    # Calculate the probability of the number of stages over time
    m = prob_num_stages_over_time(event_times, event_types, p_s, cpt, tau_max)

    # Plot the ground truth vs. the inferred state
    fig = plt.figure()

    plt.subplot(1, 2, 1)
    plt.plot(event_times, event_types, 'x')
    plt.xlim(0, tau_max)
    for c in gt_changepoints:
        plt.axvline(x=c, color='r', ls=':')
    plt.xlabel('Time index')
    plt.ylabel('Event type')
    
    plt.subplot(1, 2, 2)
    for num_cps in range(m.shape[0]):
        plt.plot(m[num_cps, :], label=f"{num_cps + 1} stages")
    for c in gt_changepoints:
        plt.axvline(x=c, color='r', ls=':')
    for e in event_times:
        plt.axvline(x=e, color='k', ls='--', alpha=0.2)       
    plt.xlabel('Time index')
    plt.ylabel('Probability of stage')
    plt.legend()

    plt.show()