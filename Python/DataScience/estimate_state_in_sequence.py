# Estimation of the state of an object.
#
# An object can be in one of a given number of states, but the state must be
# inferred from noisy data. 
#
# The state of the object evolves over time, but once it has crossed to the next
# state in the sequence, it cannot return.
#
# Observations are provided about the object, but those observations are not
# under any control, so they arrive when they are generated by an external
# source. The external system may not send data it collects to the inference 
# engine, but the probability of missing observations can be assumed to follow
# a parametric distribution.
#
# Observations from the external system do not uniquely define the state that
# the object is in, i.e. there is some ambiguity.
#
# The problem is to estimate the state of the object from the noisy and missing
# observations.

import itertools
import math
import matplotlib.pyplot as plt
import numpy as np
import random


def stage_changepoints(num_stages, tau_max):
    """Returns a list of stage changepoints."""

    assert num_stages > 1
    assert num_stages < tau_max, f"Too many stages ({num_stages}) for time {tau_max}"

    num_changepoints = num_stages - 1

    # Sample without replacement
    changepoints = random.sample(range(tau_max), num_changepoints)

    # Return a sorted list of changepoints in time order
    changepoints = sorted(changepoints)

    assert len(changepoints) == num_stages - 1
    assert len(set(changepoints)) == len(changepoints), f"Changepoints {changepoints} aren't unique"

    return changepoints


def gen_events_for_stage(t_min, t_max, p_event):
    """Generate events for the stage with time t_min <= t < t_max."""

    assert t_min <= t_max, f"Invalid times {t_min}, {t_max}"
    assert abs(sum(p_event) - 1.0) < 1e-6, f"Probability doesn't sum to 1"

    if t_min == t_max:
        return np.array([]), np.array([], dtype=int)

    # Number of events in the stage
    prop = np.random.uniform(0, 0.3)
    tau = t_max - t_min
    num_events = max(math.floor(prop*tau), 1)

    # Times of the events 
    event_times = sorted(random.sample(range(t_min, t_max), num_events))
    assert len(event_times) == num_events

    # Types of events
    event_types = [int(np.where(np.random.multinomial(1, p_event) == 1)[0][0]) for _ in range(num_events)]
    assert len(event_types) == num_events, f"Got {len(event_types)}, expected {num_events}"

    assert len(event_times) == len(event_types)

    return event_times, event_types
    

def generate_obs(p_s, cpt, tau_max):
    """Generate synthetic observations."""

    assert abs(sum(p_s) - 1.0 < 1e-6), f"Probability doesn't sum to 1"
    assert tau_max > 0

    # Sample to get the number of stages
    num_stages = np.where(np.random.multinomial(1, p_s) == 1)[0][0] + 1
    print(f"Number of stages: {num_stages}")

    if num_stages == 1:
        event_times, event_types = gen_events_for_stage(0, tau_max, cpt[0])
        gt_stages = np.repeat(0, len(event_times))
        changepoints = []
    else:
        # Determine the stage changepoints
        changepoints = stage_changepoints(num_stages, tau_max)
        print(f"Changepoints: {changepoints}")

        # Generate the ground truth stage, event time, event type
        gt_stages = np.array([])
        event_times = np.array([])
        event_types = np.array([], dtype=int)

        for s in range(num_stages):
            if s == 0:
                t_min = 0
                t_max = changepoints[0]
            elif s == num_stages - 1:
                t_min = changepoints[-1]
                t_max = tau_max
            else:
                t_min = changepoints[s-1]
                t_max = changepoints[s]

            event_times_s, event_types_s = gen_events_for_stage(t_min, t_max, cpt[s])
            num_events = len(event_times_s)
            print(f"Generated {num_events} events for stage {s} / {num_stages - 1}")

            gt_stages = np.append(gt_stages, np.repeat(s, num_events))
            event_times = np.append(event_times, event_times_s)
            event_types = np.append(event_types, event_types_s)

    assert len(gt_stages) == len(event_times), f"gt_stages = {gt_stages}, event_times = {event_times}"
    assert len(gt_stages) == len(event_types), f"gt_stages = {gt_stages}, event_types = {event_types}"

    return gt_stages, event_times, event_types, changepoints


def indicator(event_time, stage, changepoints, tau_max):
    """Indicator function returns 1 if event time is between changepoints."""

    if len(changepoints) == 0:
        return 1.0

    if stage == 0:
        t_min = 0
        t_max = changepoints[0]
    elif stage == len(changepoints):
        t_min = changepoints[-1]
        t_max = tau_max
    else:
        t_min = changepoints[stage - 1]
        t_max = changepoints[stage]

    if t_min <= event_time < t_max:
        return 1.0
    else:
        return 0.0
    

def test_indicator():
    """Unit tests for indicator()."""

    # One stage
    assert indicator(0, 0, [], 20) == 1.0
    assert indicator(19, 0, [], 20) == 1.0

    # Two stages
    assert indicator(0, 0, [10], 20) == 1.0
    assert indicator(9, 0, [10], 20) == 1.0
    assert indicator(10, 0, [10], 20) == 0.0
    assert indicator(0, 1, [10], 20) == 0.0
    assert indicator(9, 1, [10], 20) == 0.0
    assert indicator(10, 1, [10], 20) == 1.0

    # Three stages
    assert indicator(0, 0, [10, 15], 20) == 1.0
    assert indicator(0, 1, [10, 15], 20) == 0.0
    assert indicator(0, 2, [10, 15], 20) == 0.0
    assert indicator(10, 0, [10, 15], 20) == 0.0
    assert indicator(10, 1, [10, 15], 20) == 1.0
    assert indicator(10, 2, [10, 15], 20) == 0.0
    assert indicator(15, 0, [10, 15], 20) == 0.0
    assert indicator(15, 1, [10, 15], 20) == 0.0
    assert indicator(15, 2, [10, 15], 20) == 1.0


def log_likelihood(event_times, event_types, changepoints, cpt, tau_max):
    """Calculate the log-likelihood."""

    assert len(event_times) == len(event_types)

    total = 0.0
    for s in range(len(changepoints) + 1):
        for k in range(len(event_times)):
            assert s < cpt.shape[0], f"Stage {s} out of range for CPT"
            assert event_types[k] < cpt.shape[1], f"Event type {event_types[k]} out of range for CPT"

            p = cpt[s, event_types[k]] + 1e-16
            total += indicator(event_times[k], s, changepoints, tau_max) * \
                math.log(p)

    return total


def valid_changepoints(seq):
    if len(seq) == 1:
        return True
    
    for i in range(len(seq) - 1):
        if seq[i] >= seq[i+1]:
            return False
        
    return True


def test_valid_changepoints():
    assert valid_changepoints([0])
    assert not valid_changepoints([0, 0])
    assert valid_changepoints([0, 1])
    assert valid_changepoints([0, 2])
    assert not valid_changepoints([1, 0])
    assert not valid_changepoints([1, 1])
    assert valid_changepoints([0, 1, 2])
    assert not valid_changepoints([0, 1, 1])
    assert not valid_changepoints([0, 2, 1])
    assert not valid_changepoints([2, 0, 1])


def all_changepoints(num_changepoints, tau_max):
    """Construct a matrix of all possible changepoint positions."""

    assert num_changepoints >= 0
    assert tau_max > 0

    if num_changepoints == 0:
        return []

    changepoints = []

    x = list(range(tau_max))
    y = [x for _ in range(num_changepoints)]
    for seq in itertools.product(*y):
        if valid_changepoints(seq):
            changepoints.append(seq)

    return changepoints


def test_all_changepoints():
    """Unit tests for all_changepoints()."""

    assert all_changepoints(0, 3) == []
    assert all_changepoints(1, 3) == [(0, ), (1, ), (2, )]    
    assert all_changepoints(2, 3) == [(0, 1), (0, 2), (1, 2)]
    assert all_changepoints(2, 4) == [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
    assert all_changepoints(3, 4) == [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]


def run_inference(event_times, event_types, p_s, cpt, tau_max):
    """Run inference."""

    joint_probs = []

    for num_stages in range(1, len(p_s)+1):
        print(f"Running inference with {num_stages} stage(s)")

        num_changepoints = num_stages - 1
        changepoints = all_changepoints(num_changepoints, tau_max)
        print(f"  {len(changepoints)} changepoint positions")        

        if num_changepoints == 0:
            ll = log_likelihood(event_times, event_types, [], cpt, tau_max)
            prior_s = p_s[num_stages - 1]
            prior_tau = 1.0
            joint = math.exp(ll) * prior_s * prior_tau
            joint_probs.append((num_stages, [], joint))
            continue

        for c in changepoints:
            ll = log_likelihood(event_times, event_types, c, cpt, tau_max)

            prior_s = p_s[num_stages - 1]
            prior_tau = 1.0
            joint = math.exp(ll) * prior_s * prior_tau

            joint_probs.append((num_stages, c, joint))

    return joint_probs


if __name__ == '__main__':

    # Run test harness
    test_indicator()
    test_valid_changepoints()
    test_all_changepoints()

    # Number of time steps
    tau_max = 20

    # Distribution of the number of stages
    p_s = np.array([0.6, 0.3, 0.1])

    # CPT defining the probability of a given event type given the stage
    cpt = np.array([ 
        [0.1, 0.2, 0.5, 0.2, 0.0], 
        [0.1, 0.4, 0.3, 0.1, 0.1], 
        [0.0, 0.2, 0.1, 0.6, 0.1]])

    cpt = np.array([
        [1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0],
        [0, 0, 1, 0, 0]
    ])

    # Generate the ground truth stage and observed events
    gt_stages, event_times, event_types, gt_changepoints = generate_obs(p_s, cpt, tau_max)
    print(f"Ground truth stages: {gt_stages}")
    print(f"Event times: {event_times}")
    print(f"Event types: {event_types}")
    print(f"Changepoints: {gt_changepoints}")

    # Run the inference
    joint_probs = run_inference(event_times, event_types, p_s, cpt, tau_max)
    print(f"Number of joint probabilities: {len(joint_probs)}")

    # Plot the ground truth vs. the inferred state
    plt.plot(event_times, event_types, 'x')
    plt.xlim(0, tau_max + 1)
    for c in gt_changepoints:
        plt.axvline(x=c, color='r', ls=':')
    plt.xlabel('Time index')
    plt.ylabel('Event type')
    plt.show()